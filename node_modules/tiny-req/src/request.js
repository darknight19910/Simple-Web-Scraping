/*jshint browserify: true */

'use strict';

var BPromise = require('bluebird');
var util = require('util');
var HTTP = 'http';
var HTTPS = 'https';

var Request = function(args) {
    if (!(this instanceof Request)) {
        return new Request(args);
    }
    if (args && args.protocol) {
        // remove the trailing colon if it exists
        if (~args.protocol.indexOf(':')) {
            args.protocol = args.protocol.substr(0, args.protocol.indexOf(':'));
        }
        if (args.protocol === HTTP || args.protocol === HTTPS) {
            this.protocol = args.protocol;
        } else {
            throw new Error('supported protocols are http and https.');
        }
    } else {
        throw new Error('args.protocol is required.');
    }

    this.timeout = args.timeout || 90000; // 90s default timeout
};

Request.prototype.exec = function(options, postData) {
    var self = this;

    if (postData) {
        options.headers['Content-Length'] = postData.length;
    }

    return new BPromise(function(resolve, reject) {
        var req = (self.protocol === HTTP ? require('http') : require('https')).request(options, function(res) {
            var str = '';
            var arr = [];
            var isBuffer;
            res.on('data', function(chunk) {
                if (chunk.constructor.name === 'Uint8Array' || chunk.constructor.name === 'Buffer') {
                    isBuffer = true;
                    arr.push(chunk);
                } else {
                    isBuffer = false;
                    str += chunk;
                }
            }).on('end', function() {
                if (isBuffer) {
                    res.buffer = new Buffer(Buffer.concat(arr));
                    if (!process.browser) {
                        res.body = res.buffer.toString('utf8');
                    }
                    res.buffer = new Buffer(Buffer.concat(arr));
                } else {
                    res.body = str;
                }
                if (res.statusCode >= 200 && res.statusCode < 400) {
                    resolve(res);
                } else {
                    reject(res);
                }
            }).on('error', function(error) {
                reject(error);
            });
        });
        req.on('error', function(error) {
            reject(error);
        });
        req.on('socket', function(socket) {
            socket.setTimeout(self.timeout);
            socket.on('timeout', function() {
                req.abort();
            });
        });

        if (postData) {
            req.write(postData);
        }
        req.end();
    });
};

module.exports = Request;
